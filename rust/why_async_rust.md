# [翻译]Rus为什么选择async

［[原文](https://without.boats/blog/why-async-rust/)］: https://without.boats/blog/why-async-rust/

Rust的async/await（async/await）语法一发布就引发了极大的关注和热情。回顾[Hacker News](https://news.ycombinator.com/item?id=21473418)当时的评论：

  *这将是一个重大转折点。我相信许多人都在等待这一刻，来开始使用Rust。我自己就确实是这样。*
  *此外，它还具有所有优秀特质：开源、高品质的工程、公开设计、对复杂软件的众多贡献。真正令人振奋！*

但最近，人们的反应变得更加复杂。再次引用[Hacker News](https://news.ycombinator.com/item?id=37436413)上的一条评论，讨论了一篇最近的博文：

  *我真的无法理解有人怎么会看着Rust的异步混乱并认为这是一个本就声称编写复杂的语言的好设计。*
  *我努力去理解它，但我的天，它真是一团糟。它影响到了一切。我非常喜欢Rust，现在大多数编程工作都在使用它，但每当我遇到重度异步的Rust代码，我就会感到头疼和困惑。*

当然，这些评论并不能全面代表情况：即使在四年前，也有人表达了担忧。在同一讨论Thread中，关于头疼和视线模糊的评论旁，也有许多人热情地支持异步Rust。但可以说，反对的声音变得更多，语气也更加强硬。这在一定程度上是炒作周期的自然演变，但随着我们与最初的设计过程渐行渐远，一些背景知识也逐渐丧失。

在2017至2019年间，我主导了async/await语法的设计，与其他人合作，并在前人的基础上进一步发展。当有人说他们不明白怎么会有人看着这个“混乱”还“认为这是个好设计”时，请原谅我感到不安。请允许我详细而稍显杂乱地解释异步Rust的由来、它的目的，以及为什么在我看来，对于Rust而言，没有其他可行的替代方案。我希望通过这个过程，能够更深入地阐释Rust设计的广度和深度，而不仅仅是重复过去的理由。

## 有关术语的一些背景
这场辩论的核心问题是Rust决定采用“无栈协程”方法来实现用户空间的并发性。这个讨论中涉及了许多术语，对它们不全部熟悉是合理的。

首先我们需要弄清楚的是这个功能的真正目的：“用户空间并发”。主要的操作系统提供了一系列相似的接口来实现并发：你可以创建线程，并在这些线程上通过系统调用执行IO操作，这会阻塞线程直到操作完成。这些接口的问题在于它们会带来一定的开销，这些开销在追求特定性能目标时可能成为限制因素。这些开销主要有两个方面：
  - 1. 在内核与用户空间之间进行上下文切换在CPU周期方面代价昂贵。
  - 2. 操作系统线程拥有较大的预分配栈，增加了每个线程的内存开销。

这些限制在一定程度上是可接受的，但对于需要大规模并发的程序来说，它们就不太适用。解决方法是使用非阻塞IO接口，并在单个操作系统线程上调度多个并发操作。程序员可以“手动”实现这一点，但现代编程语言通常提供工具来简化这一过程。从抽象层面来看，编程语言有将工作分解成任务，并将这些任务调度到线程上的方式。Rust采用的是async/await系统。

在这个设计空间里，首要的选择是协作调度和抢占式调度之间的决策。任务是必须“协作性”地将控制权交回调度子系统，还是可以在运行过程中的某个时刻被“抢占式”地中断，而任务本身对此毫不知情？

在这些讨论中经常出现的一个术语是协程，其使用方式有些自相矛盾。协程是一种可以暂停然后稍后继续的函数。这里的一个主要模糊点是，有些人用“协程”来指一种具有明确的暂停和恢复语法的函数（这对应于协作性调度的任务），而有些人则用它来指任何可以暂停的函数，即使暂停是由语言运行时隐式执行的（这也包括抢占式调度的任务）。我更倾向于第一个定义，因为它提供了某种有意义的区分。

另一方面，Go语言的Goroutines是一种支持并发的、抢占式调度的任务功能。它们具有与线程相同的API，但是作为语言的一部分实现，而不是作为操作系统的原语。在其他语言中，它们通常被称为虚拟线程或绿色线程。因此，按照我的定义，goroutines不是协程，但其他人使用更广泛的定义认为goroutines是一种协程。在Rust中，这种方法被称为绿色线程，这是已经使用的术语。

第二个选择维度是有栈协程和无栈协程之间的区别。有栈协程拥有与操作系统线程相同的程序栈：当函数作为协程的一部分被调用时，它们的帧被推到栈上；当协程让出控制权时，栈的状态被保存，以便它可以从相同位置恢复。而无栈协程则以不同的方式存储它恢复所需的状态，例如在一个继续体或状态机中。当它让出控制权时，它正在使用的栈被接管它的操作所使用，并且当它恢复时，它重新控制栈，而那个继续体或状态机被用来从中断的地方恢复协程。

在Rust和其他语言中，关于async/await的一个常见问题是“函数着色问题”——抱怨为了得到异步函数的结果，你需要采取不同的操作（比如等待它），而不是像通常那样调用它。绿色线程和有栈协程机制都可以避免这种情况，因为特殊的语法正是用来指示正在管理协程的无栈状态时发生的特殊情况（具体内容取决于语言）。

Rust的async/await语法是无栈协程机制的一个例子：一个异步函数被编译成一个返回Future的函数，这个Future用来存储协程在让出控制权时的状态。这场辩论的核心问题是，Rust是否正确地选择了这种方法，或者它是否应该采用一种更像Go的“有栈”或“绿色线程”方式，理想情况下，不需要显式语法来“着色”函数。

## [翻译]异步Rust的发展

### 绿色线程
[Hacker News](https://news.ycombinator.com/item?id=37791635)上的第三条评论很好地反映了我在这场辩论中经常看到的观点：

  *人们想要的是通过有栈协程和通道以及基于工作窃取的执行器来实现结构化并发。*
  *除非有人做出实际演示，并将其与基于Futures的async/await进行比较，我认为没有什么有成效的讨论。*

撇开对结构化并发、通道和工作窃取执行器的讨论（这些完全是独立的关注点），这类评论令人困惑的是，最初Rust确实采用了有栈协程机制，表现为绿色线程。这个机制在2014年底被移除，就在1.0版本发布之前不久。理解这一移除的原因将有助于我们弄清楚Rust为何采用async/await语法。

对于任何绿色线程系统——无论是Rust、Go还是其他语言的——一个主要问题是如何处理这些线程的程序栈。要记住，用户空间并发机制的一个目标是减少操作系统线程使用的大型预分配栈的内存开销。因此，绿色线程库通常试图采用一种机制，以较小的栈启动线程，并只在需要时扩展它们。

实现这个目标的一种方法是所谓的“分段栈”，其中栈是一个由小栈段组成的链表；当栈超出其段的界限时，就会向链表中添加一个新段，当它缩小时，该段会被移除。这种技术的问题在于，它使得向栈中推送一个栈帧的成本变得高度可变。如果帧适合当前段，这几乎没有成本。如果不适合，就需要分配一个新段。特别恶劣的情况是，热循环中的函数调用需要分配一个新段。这就在循环的每次迭代中增加了分配和回收操作，对性能产生了显著影响。而且这对用户来说是完全不透明的，因为用户无法预知调用函数时栈将有多深。Rust和Go最初都采用了分段栈，但后来因为这些原因放弃了这种方法。

另一种方法是“栈复制”。在这种方法中，栈更像一个Vec而不是链表：当栈达到其限制时，它会被重新分配得更大，以避免触及限制。这样可以使栈从小开始，根据需要逐渐增长，没有分段栈的缺点。这种方法的问题是，重新分配栈意味着需要复制它，这又意味着栈会在内存中处于一个新的位置。任何指向栈的指针此时都将变得无效，需要某种机制来更新这些指针。

[Go采用栈复制方法](https://blog.cloudflare.com/how-stacks-are-handled-in-go/)，并从一个事实中获益：在Go中，栈内指针只能存在于同一栈内，因此只需扫描该栈来重写指针。即便如此，这也需要运行时类型信息，这是Rust不具备的。但Rust还允许栈外的指针指向一个栈——它们可能在堆中，或者在另一个线程的栈里。跟踪这些指针的问题最终与垃圾回收的问题相同，区别在于不是释放内存而是移动它。Rust不能采用这种方法，因为Rust没有垃圾收集器，所以最终没有采用栈复制。相反，Rust通过使其绿色线程变大，类似于操作系统线程，解决了分段栈的问题。但这就消除了绿色线程的一个关键优势。

即使在像Go这样可以调整栈大小的情况下，绿色线程在尝试与其他语言编写的库集成时也面临着一些不可避免的成本。C ABI及其操作系统栈是各种语言共有的最小共同点。将代码从绿色线程执行切换到操作系统线程栈运行对FFI来说可能代价过高。Go接受了这种FFI成本；C#最近因为这个原因[终止了一项](https://github.com/dotnet/runtimelab/issues/2398)绿色线程的尝试。

这对Rust来说尤其成问题，因为Rust的设计目标是支持如将Rust库嵌入用其他语言编写的二进制文件，以及在没有时钟周期或内存运行虚拟线程运行时的嵌入式系统上运行等用例。为了解决这个问题，Rust将绿色线程运行时设置为可选，并可以编译为在本地线程上运行，使用阻塞IO。这被设计为最终二进制文件的编译时决策。因此，一段时间内，存在两种Rust：一种使用阻塞IO和本地线程，另一种使用非阻塞IO和绿色线程，所有代码都旨在与这两种方式兼容。这并未取得好的发展，最终[RFC 230](https://github.com/rust-lang/rfcs/pull/230)将绿色线程从Rust中移除，理由包括：
  - 在绿色和本地线程之间的抽象并非“零成本”，在进行IO时导致了不可避免的虚拟调用和分配，这对本地代码来说是不可接受的。
  - 它迫使本地线程和绿色线程支持相同的API，即使这并不合理。
  - 它并非完全互操作，因为即使在绿色线程上，仍然可以通过FFI调用本地IO。

一旦绿色线程被移除，高性能用户空间并发的问题仍然存在。Future特征和后来的async/await语法为解决这个问题而开发。但要理解这一发展路径，我们需要进一步回顾Rust解决另一个问题的方法。

### 迭代器

我认为通往异步Rust之路的真正起点可以追溯到2013年，一个前贡献者Daniel Micay在邮件列表中发表的一篇帖子。这篇帖子与async/await、futures或非阻塞IO无关，而是关于迭代器的。Micay提出将Rust转向所谓的“外部”迭代器，正是这一转变——以及它与Rust的所有权和借用模型的有效结合——不可避免地将Rust引向了async/await。显然，当时没有人知道这一点。

Rust一直禁止通过与另一个变量有别名的绑定来修改状态——这个“可变的XOR别名”的原则对早期的Rust来说和今天一样核心。但最初它是用不同的机制来强制执行的，而不是通过生命周期分析。那时，引用仅仅是“参数修饰符”，在概念上类似于Swift中的“inout”修饰符。2012年，Niko Matsakis提出并实现了Rust生命周期分析的首个版本，将引用提升为真正的类型，并使其能够嵌入结构体中。

尽管生命周期分析的转变因其在塑造今天的Rust方面的巨大影响而备受认可，但它与外部迭代器的共生互动，以及该API在确立Rust当前定位中的基础重要性，还没有得到足够的重视。在采用“外部”迭代器之前，Rust使用了一种基于回调的方法来定义迭代器，如果用现代Rust来表示，它看起来是这样的：

```rust
enum ControlFlow {
    Break,
    Continue,
}

trait Iterator {
    type Item;

    fn iterate(self, f: impl FnMut(Self::Item) -> ControlFlow) -> ControlFlow;
}
```

以这种方式定义的迭代器在集合的每个元素上调用其回调函数，除非它返回ControlFlow::Break，在这种情况下，迭代器应该停止迭代。for循环的主体被编译成一个闭包，传递给被遍历的迭代器。这样的迭代器比外部迭代器容易编写得多，但这种方法存在两个关键问题：
  - 1. 语言无法保证当循环需要中断时迭代真的会停止，因此你不能依赖于这一点来确保内存安全。这意味着像从循环中返回引用这样的事情是不可能的，因为循环实际上可能会继续。
  - 2. 它们不能用于实现交织多个迭代器的泛型组合器，如zip，因为API不支持交替地通过一个迭代器然后又通过另一个迭代器。

因此，Daniel Micay提议将Rust转向使用“外部”迭代器，这完全解决了这些问题，并且拥有今天Rust用户所熟悉的接口：
```rust
trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```
外部迭代器与Rust的所有权和借用系统完美结合，因为它们本质上编译成一个结构体，该结构体内部持有迭代状态，并因此可以包含对被迭代数据结构的引用，就像任何其他结构体一样。而且，由于单态化，通过组合多个组合器构建的复杂迭代器也编译成一个单一结构体，使其对优化器透明。唯一的问题是它们手动编写起来更困难，因为你需要定义将用于迭代的状态机。预示着未来的发展，Daniel Micay当时写道：
  *在未来，Rust可以拥有类似C#中的yield语句的生成器，编译成一个快速的状态机，而不需要上下文切换、虚拟函数甚至闭包。这将消除手动使用外部迭代器编写递归遍历的难度。*

尽管生成器的进展并不迅速，但最近发布的一个令人兴奋的RFC表明，我们可能很快就会看到这个特性。

即使没有生成器，外部迭代器也证明是一个巨大的成功，并且其技术的总体价值被认可。例如，Aria Beingessner在“Entry API”中使用了类似的方法来访问映射条目。值得注意的是，在API的RFC中，她将其称为“类似迭代器”。她的意思是，该API通过一系列组合器构建状态机，使其对编译器高度可读并因此可优化。这种技术具有持久价值。

### Futures
在需要替换绿色线程时，Aaron Turon和Alex Crichton开始模仿许多其他语言中使用的API，这些API被称为futures或promises。这类API基于所谓的“继续传递风格”。以这种方式定义的future会接受一个回调作为额外参数（称为继续），并在future完成时作为其最终操作调用继续。这是大多数语言中定义这种抽象的方式，而大多数语言的async/await语法也编译成这种继续传递风格。

在Rust中，这类API可能看起来像这样：
```rust
trait Future {
    type Output;

    fn schedule(self, continuation: impl FnOnce(Self::Output));
}
```

Aaron Turon和Alex Crichton尝试了这种方法，但如Aaron Turon在一篇发人深省的博客文章中所述，他们很快就遇到了一个问题：使用继续传递风格过于频繁地需要分配回调函数。Turon举了join的例子：join接收两个future，并同时运行它们。join的继续需要由两个子future共同拥有，因为无论哪个最后完成都需要执行它。这最终需要通过引用计数和分配来实现，这对Rust来说是不可接受的。

相反，他们研究了C程序员是如何实现异步编程的：在C语言中，程序员通过构建状态机来处理非阻塞IO。他们想要的是一种Future的定义，可以编译成C程序员会手动编写的那种状态机。经过一些实验，他们确定了他们所称的“基于就绪性”的方法：
```rust
enum Poll<T> {
    Ready(T),
    Pending,
}

trait Future {
    type Output;

    fn poll(&mut self) -> Poll<Self::Output>;
}
```

而不是存储一个继续，future由某个外部执行器轮询。当一个future处于挂起状态时，它会存储一个唤醒执行器的方式，当它准备好再次被轮询时执行该方式。通过这种反转控制的方式，他们不再需要存储一个回调来处理future完成时的情况，这使得他们可以将一个future表示为单个状态机。他们在这个接口之上构建了一系列组合器，这些组合器都会被编译成一个单一的状态机。

从基于回调的方法转换为外部驱动，将一组组合器编译成单个状态机，甚至这两个API的确切规范：如果你读过上一节，这些都会听起来非常熟悉。从继续传递转换为轮询正是2013年迭代器所进行的相同转换！再次，正是Rust能够处理带有生命周期的结构体，因此能够处理从外部借用状态的无栈协程，使其能够在不违反内存安全的情况下将future优化地表示为状态机。无论是应用于迭代器还是future，通过较小的组件构建单一对象状态机的这种模式是Rust工作方式的关键。它几乎自然地从语言中产生出来。

我想暂时强调迭代器和future之间的一个区别：像Zip这样交织两个迭代器的组合器在类似回调的方法中甚至是不可能的，除非你的语言有某种原生的协程支持。另一方面，如果你想交织两个future，比如Join，基于继续的方法可以支持这一点：它只是带来一些运行时成本。这解释了为什么外部迭代器在其他语言中很常见，但Rust在将这种转换应用于future方面是独一无二的。

在其初始版本中，futures库的设计原则是用户将以与构建迭代器相同的方式构建future：低级库作者将使用Future特性，而编写应用程序的用户将使用futures库提供的一系列组合器来构建更复杂的future。遗憾的是，当用户尝试遵循这种方法时，他们立即面临了令人沮丧的编译器错误。问题是，当future被生成时，需要“逃脱”周围的上下文，因此不能从该上下文中借用状态：任务必须拥有其所有状态。

这对future组合器来说是一个问题，因为经常需要在构成future的一系列动作链中的多个组合器中访问该状态。例如，用户常常会这样写代码：先调用对象上的一个“异步”方法，然后是另一个，
```rust
foo.bar().and_then(|result| foo.baz(result))
```

问题在于，foo在bar方法中被借用，然后又在传递给and_then的闭包中被借用。用户实际上想要做的是在一个await点“保持状态”，这个await点是通过future组合器的链接形成的；这通常导致让人困惑和难以理解的借用检查器错误。对此最直观的解决方案是将状态存储在Arc和Mutex中，这并非零成本，并且更重要的是，随着系统复杂度的增长，它变得非常笨重和不便。
```rust
let foo = Arc::new(Mutex::new(foo));
foo.clone().lock().bar()
   .and_then(move |result| foo.lock().baz(result))
```

尽管最初的实验中futures展示了很好的基准测试结果，但这一限制的结果是用户无法使用它们来构建复杂的系统。这就是我参与这个故事的时刻。

### async/await

到2017年底，显然futures生态系统因为糟糕的用户体验而未能顺利推进。futures项目的终极目标一直是实现所谓的“无栈协程转换”，在这种转换中，使用异步和等待语法操作符的函数可以被转换成产生futures的函数，从而避免用户不得不手动编写futures。Alex Crichton已经开发了一个基于宏的async/await实现作为一个库，但这几乎没有引起关注。需要做出一些改变。

Alex Crichton宏的最大问题之一是，如果用户试图在await点之后保持对future状态的引用，它会产生一个错误。这实际上与用户在使用future组合器时遇到的借用问题是同一个问题，再次出现在新语法中。future在等待时无法持有对自身状态的引用，因为这需要编译成一个自引用结构体，而Rust对此没有支持。

将这与绿色线程的问题进行比较是有趣的。我们解释futures编译为状态机的一种方式是说，状态机是一个“完美尺寸的栈” - 与绿色线程的栈不同，后者必须增长以容纳任何线程栈可能具有的未知大小的状态，一个编译的future（无论是手动实现的，通过组合器实现的，还是通过异步函数实现的）正好与它需要的大小一样大。因此，我们没有在运行时增长这个栈的问题。

然而，这个栈被表示为一个结构体，而在Rust中移动结构体始终是安全的。这意味着尽管我们不需要在执行过程中移动future，根据Rust的规则我们需要能够做到这一点。因此，我们在绿色线程中遇到的栈指针问题在新系统中重新出现。这一次，我们有一个优势，即我们不需要能够移动future，我们只需要表达future是不可移动的。

实现这一点的初步尝试是定义一个新的特性，名为Move，它将用于将协程排除在可以移动它们的API之外。这遇到了一些我之前[记录](https://without.boats/blog/changing-the-rules-of-rust)的向后兼容性问题。我对async/await的主要观点有三点：
  - 1. 我们需要在语言中加入async/await语法，以便用户可以使用类似协程的函数构建复杂的futures。
  - 2. async/await语法需要支持将这些函数编译成自引用结构体，以便用户可以在协程中使用引用。
  - 3. 这个功能需要尽可能快地发布。

这三个观点的结合促使我寻找替代Move特性的解决方案，一个不需要对语言进行任何重大破坏性改变的解决方案。

我的最初计划远不如我们最终得到的结果。我提出的是让poll方法变为不安全，并包含一个原则，即一旦开始轮询一个future，你就不能再移动它。这个方法简单、可以立即实施，但极其粗暴：它会使每一个手写的future变得不安全，并强加了一个难以核实的要求，而且没有编译器的帮助。它最终可能会因为某些健全性问题而陷入困境，肯定也会引起极大争议。

因此，Eddy Burtescu提出的一些建议引导我朝着一个更好的API方向前进，这非常好，这个API可以让我们以更细致的方式强制执行所需的不变量。这最终成为了Pin类型。Pin类型本身引起了一些困扰，但我认为它无疑是我们当时考虑的其他选项的改进，因为它针对性强、可强制执行，并且能够及时发布。

回顾起来，固定方法有两类问题：
  - 1. 向后兼容性：一些已存在的接口（特别是Iterator和Drop）因各种原因应支持不可移动类型，这限制了语言进一步发展的选项。
  - 2. 暴露给最终用户：我们的初衷是编写“普通异步Rust”的用户永远不需要处理Pin。大部分情况下这是真的，但有一些显著的例外。几乎所有这些例外都可以通过一些语法改进来解决。唯一真正糟糕的（对我个人来说也很尴尬）是你需要固定一个future特征对象来等待它。这是一个不必要的错误，现在要修复它将是一个破坏性变更。

关于async/await的其他决策只涉及语法，我不会在这个已经过长的帖子中详述。

## 组织层面的考虑

我之所以探讨这些历史，是为了展示一系列关于Rust的事实，这些事实不可避免地引导我们进入特定的设计空间。首先是，Rust缺乏运行时系统，使得绿色线程成为不可行的解决方案，这是因为Rust需要支持嵌入（包括嵌入到其他应用和在嵌入式系统上运行），以及Rust无法执行绿色线程所需的内存管理。第二点是，Rust天然具备表达编译成高度可优化状态机的协程的能力，同时仍然保持内存安全，我们不仅在futures上而且在迭代器上都利用了这一点。

但这段历史还有另一面：为什么我们追求用户空间并发的运行时系统？为什么要有futures和async/await？这个讨论通常有两种形式：一方面，有些人习惯于使用类似epoll这样的接口“手动”管理用户空间并发；这些人有时会嘲笑async/await语法是“网络垃圾”。另一方面，有些人简单地说“你不需要它”，并建议使用更简单的操作系统并发，如线程和阻塞IO。

在没有用户空间并发设施的语言中实现高性能网络服务的人，比如C语言，倾向于使用手写状态机。Future抽象就是设计成这种东西，但不需要手动编写状态机：协程转换的核心就是编写看似“函数永不让出”的命令式代码，但让编译器生成状态转换，以便在函数可能阻塞时将其挂起。这些好处不容小觑。最近的一个curl [CVE](https://daniel.haxx.se/blog/2023/10/11/how-i-made-a-heap-overflow-in-curl/) 最终是因为在状态转换期间未能识别需要保存的状态而引起的。在手动实现状态机时，很容易犯这种逻辑错误。

在Rust中推出async/await语法的目标是提供一个避免这些错误同时保持相同性能特性的功能。这类系统，通常用C或C++编写，被认为完全处于我们的目标受众范围内，考虑到我们提供的控制级别和缺乏内存管理运行时。

2018年初，Rust项目承诺当年发布一个新的“版次”，以解决自1.0版以来出现的一些语法问题。还决定利用这个版次作为一个机会，推广一个关于Rust已准备好大显身手的叙述；Mozilla团队主要由编译器黑客和类型理论家组成，但我们对市场营销有一些基本的了解，并认识到这个版次是一个吸引人们关注产品的机会。我向Aaron Turon提议，我们应该专注于四个基本用户故事，这些似乎是Rust的增长机会。这些是：
  - 嵌入式系统
  - WebAssembly
  - 命令行接口
  - 网络服务
这个评论是“领域工作组”创建的契机，这些工作组旨在成为专注于特定使用[“领域”](https://internals.rust-lang.org/t/announcing-the-2018-domain-working-groups/6737)的跨功能团队（与负责某些技术或组织范畴的现有“团队”形成对比）。自那时以来，Rust项目中的工作组概念已经变化，并且大多失去了这种意义，但这是另一话题。

async/await的工作最初由“网络服务”工作组领先推进，最终被简称为异步工作组（直到今天仍以这个名称存在）。然而，我们也非常清楚，鉴于其缺乏运行时依赖，异步Rust也可能对其他领域大有裨益，特别是嵌入式系统。我们在设计这个功能时考虑到了这两种用例。
虽然通常不言而喻，但很明显，Rust想要成功，需要行业采纳，这样一旦Mozilla不再愿意资助一个实验性新语言，它就能继续获得支持。而且很明显，通往短期行业采纳的最可能途径是网络服务，特别是那些当时由于性能特性而被迫用C/C++编写的服务。这种用例非常符合Rust的定位 - 这些系统需要高度控制来实现它们的性能要求，但避免可利用的内存漏洞至关重要，因为它们暴露在网络中。

网络服务的另一个优势是，这个软件行业的分支有灵活性和意愿迅速采纳像Rust这样的新技术。其他领域 - 并且仍然是！- 对Rust来说是长期可行的机会，但它们被视为不太快采纳新技术（嵌入式），依赖于尚未广泛采纳的新平台（WebAssembly），或不是特别有利可图的工业应用，能为语言带来资金（命令行接口）。我以为Rust的生存依赖于这个功能的坚定热情推动了async/await。

在这方面，async/await取得了巨大的成功。Rust基金会的许多最重要的赞助商，特别是那些支付开发者费用的赞助商，依赖于async/await在Rust中编写高性能网络服务，作为他们资助的主要用例之一。在嵌入式系统或内核编程中使用async/await也是一个日益增长、前景光明的领域。async/await如此成功，以至于对它的最常见抱怨是生态系统过于以它为中心，而不是“普通”的Rust。

对于那些更愿意只使用线程和阻塞IO的用户，我不知道该说什么。当然，我认为有很多系统对这种方法来说是合理的。而且Rust语言中没有任何东西阻止他们这样做。他们的反对似乎是因为crates.io上的生态系统，尤其是编写网络服务的生态系统，以使用async/await为中心。偶尔，我看到一个库以“货栈式崇拜”的方式使用async/await，但大多数情况下似乎可以安全地假设库的作者实际上想要执行非阻塞IO并获得用户空间并发的性能好处。

我们都无法控制其他人决定做什么，事实就是大多数在crates.io上发布网络相关库的人都想使用异步Rust，无论是出于商业原因还是出于兴趣。我希望在非异步上下文中使用这些库变得更容易（例如，将类似[pollster](https://docs.rs/pollster/0.3.0/pollster/)的API引入标准库），但很难知道该对那些抱怨在线免费发布代码的人没有完全相同用例的人说什么。

## 未完待续

尽管我坚持认为对于Rust来说没有其他选择，但我并不认为async/await对所有语言都是正确的替代方案。特别是，我认为有可能存在一种语言，它提供与Rust相同的可靠性保证，但对值的运行时表示的控制更少，使用有栈协程而不是无栈协程。我甚至认为，如果这样的语言以能够同时用于迭代和并发的方式支持这样的协程，那么这种语言可以完全不需要生命周期，同时仍然消除由别名可变性引起的错误。如果你阅读Graydon Hoare的[笔记](https://graydon2.dreamwidth.org/307291.html)，你会看到这种语言是他最初的目标，然后Rust改变了方向，成为了一种能与C和C++竞争的系统语言。

我认为，如果这种语言存在，有些Rust用户会非常乐意使用它，我理解他们为什么不喜欢处理低级细节的固有复杂性。过去，这些用户抱怨的是众多的字符串类型，现在他们更可能抱怨异步。我希望存在一种具有与Rust相同保证的语言来满足这个用例，但问题并不在于Rust。

尽管我相信async/await是Rust的正确方向，我也认为对今天的异步生态系统状态不满是合理的。我们在2019年发布了一个最小可行产品(MVP)，tokio在2020年发布了1.0版本，但自那以后的停滞程度比我认为任何参与者都希望的

