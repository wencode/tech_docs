# 使用 Tree-sitter 实现的低延迟和语法感知编辑功能

*原文：[Enabling low-latency, syntax-aware editing using Tree-sitter](https://zed.dev/blog/syntax-aware-editing)*

在编程过程中，当我们完全沉浸在代码世界，我们对程序的理解更多地基于它的逻辑结构而不是文本形式。一个优秀的代码编辑器应该能帮助我们维持这种专注状态，让我们能清楚地识别代码结构并进行操作，而不需要关注每一个字符。

Zed 编辑器，就像许多其他编辑器一样，采用了语言服务器协议（Language Server Protocol）来支持多种标准的编程语言智能化功能。但除此之外，还有很多特性需要编辑器自身能够在语法层面理解代码。在本文中，我会详细介绍 Zed 是如何实现语法感知编辑的，以及展示 Zed 中一些与语法相关的特性是如何被实施的。

## Tree-Siter

在编辑器内解析代码面临一些挑战，这些挑战是大多数解析器未被设计来应对的。源代码的频繁更改要求能够迅速重新进行解析。往往在我们编辑的区域内，代码可能暂时出现错误，但我们仍需正确解析整个文件的其余部分。面对众多不同的编程语言，所有编辑器功能都需要跨语言保持一致性。

正因如此，我花费了数年时间开发 Tree-sitter，这是一个在某些约束条件下工作的开源解析框架。Tree-sitter 依据上下文无关语法的精确规范来解析代码，并采用了一种名为广义LR（GLR）解析的算法，能够为几乎所有编程语言编写语法。它利用增量解析技术在代码编辑后实现高效重解析，并引入了一种创新的错误恢复机制，即便是文件状态不正确时也能得到有用的解析结果。

## 利用具体语法树
通过 Tree-sitter 解析文件时，它会创建一个称为具体语法树（CST）的数据结构，这与抽象语法树(AST)相似，但不同之处在于它能够保留文档中每个标记（token）的位置信息。这一点对于那些需要直接查看和操作代码的应用而言尤为重要，不仅仅是为了提取代码的含义。那么，拥有了反映源文件结构的具体语法树后，我们该如何利用这个CST来提升代码编辑的体验呢？

CST的一个简单而实用的应用是一种称为“语法感知选择”的功能，它在编辑器中包含两个命令：“选择较大的语法节点”和“选择较小的语法节点”，这两个命令默认分别绑定到alt-up和alt-down键。通过这些命令，用户可以快速选中他们想要修改的代码区域，而无需逐字符地移动光标。

特别是在同时用多个光标编辑多处代码时，这些命令显得格外有用。经常情况下，你想要编辑的代码片段虽然长度不同，但在语法结构上是一致的。

![](https://zed.dev/img/post/syntax/multi-cursor-syntax-selection.gif)
*使用语法感知的多光标编辑*

为了实施这些命令，我们仅需依赖具体语法树（CST）本身，因为我们不需要区分具体的语法节点类型，我们唯一需要了解的是文档中的哪些区域与语法树的节点相对应。然而，对于其他大多数语法感知功能，我们则需要对节点有更详细的了解。下面我们来探讨这些功能是如何实现的。

## 树查询功能
在很多代码分析工作中，我们经常需要在语法树里查找符合特定结构模式的部分。为了简化这种工作，Tree-sitter 引入了一种查询引擎。通过树查询，你可以使用一种简洁的声明式语言来定义语法模式，并能有效地遍历语法树中所有匹配这些模式的节点集合。

下面是一个针对 JavaScript 语法树的查询示例。在此查询中，我们查找三种不同的模式。第一种模式识别任何将箭头函数赋值给对象属性的情况（如 a.b = (c) => d）。第二种模式识别任何对 this 属性的引用（如 this.x）。而第三种模式识别任何标识符。

```
(assignment_expression
  left: (member_expression
    property: (property_identifier) @the_assigned_method)
  right: (arrow_function))
 
(member_expression
  object: (this)
  property: (property_identifier) @the_property_of_this)
 
(identifier) @the_variable
```

在查询语句中，以@符号起始的名称，如 @the_assigned_method 和 @the_property_of_this，是自定义的。它们被称作捕获标记，用于为模式中前一个节点指定一个特定名称。这样，每当模式成功匹配时，你就可以通过这些捕获名称来获取对应的匹配节点。

构建查询时，Tree-sitter 会把查询的源代码编译成一个紧凑的状态机。这个状态机的设计允许通过对语法树单次深度优先遍历来找到所有的查询匹配项。在查询执行过程中，我们会遍历语法树，并保持一组正在匹配的项目。每进入一个节点，我们就会推进所有下一个步骤由当前节点满足的匹配项，移除所有未能成功的匹配，并将所有完成的匹配反馈给调用方。

查询语言还包括一些用于定义更复杂模式的特性。想要了解更多，请查阅 Tree-sitter 文档中的查询部分。

Zed通过树查询来定义所有与语言相关的语法树处理规则，这大大简化了新语言的集成过程：不需要为每种语言单独编写定制化的程序代码。我们只需添加一个 Tree-sitter 解析器和相应的查询集合即可。

## 语法高亮
优秀的语法高亮能够通过颜色的一致使用来明确展示文件中每个标记的作用。传统上，多数代码编辑器利用正则表达式来实现语法高亮，这种做法一次处理一行文本，大致识别特定的代码结构。这种方式往往导致高亮显示的结果不尽人意，缺乏一致性。

通过利用语法树，我们可以实现更精准且一致的代码高亮。对于每一种编程语言，我们只需定义主题中不同的样式和颜色如何与语法树的不同节点对应。

Zed 采用树查询来确定这种映射关系。高亮查询利用捕获名称，这些名称与主题中的样式名称相对应。举个例子，这是一个针对 JavaScript 的高亮查询示例：

```
["do" "for" "while"] @keyword
 
(function
  name: (identifier) @function)
 
(pair
  key: (property_identifier) @function.method
  value: [(function) (arrow_function)])
```

在此查询中，关键字 do、for 和 while 会使用主题指定的关键字颜色显示，函数声明的名称会使用函数颜色。对象字面量中作为函数的键值会显示为 function.method 颜色（或者如果主题没有为 function.method 定义一个特定颜色，就使用函数颜色）。

采用这种方法，Zed 的主题可以非常简洁，且不依赖于任何特定的编程语言。下面是 Zed “One Dark”主题的一个代码片段：

```
{
    "keyword": {
        "color": "#B478CF"
    },
    "function": {
        "color": "#74ADE9"
    },
    "emphasis.strong": {
        "color": "#C0966B",
        "weight": "bold"
    },
    "link_text": {
        "color": "#74ADE9",
        "italic": false
    }
}
```

## 符号概览
符号概览通过罗列文件中定义的符号及展示它们之间的层级关系，帮助用户更容易地浏览代码。在 Zed 中，我们用两种方式展示文件的概览。编辑器顶部始终显示的面包屑导航列出了包含当前光标位置的符号。而大纲弹窗则列出了文件内的所有符号，允许用户通过模糊筛选快速跳转至任意符号。

大纲弹窗功能非常强大，因为它的模糊搜索不仅限于单个符号名称。比如，你可以输入类似于 buf lang 的查询来迅速找到所有与 lang 相匹配的符号，这些符号位于与 buf 相匹配的父符号之下。这样的搜索结果会包括 Buffer::set_language 和 BufferSnapshot::language_at 等方法。

![](https://zed.dev/img/post/syntax/outline-view.png)
*大纲模式, 可以使用模糊搜索*

大纲项目不仅仅包括符号名称，还包括一些上下文信息，比如 Rust 语言中的函数名称 fn。如果你的模糊查询包含多个词汇，除了匹配名称本身，你还可以在这些上下文信息中匹配这些词汇。例如，通过输入 pub async fn，你可以列出文件中所有的公开异步函数。

为了让大纲功能以这种方式运作，并且在我们支持的所有编程语言中提供一致的体验，我们决定不采用语言服务器协议提供的大纲功能。符号大纲本质上是基于语法的，并且仅限于单个文件，因此我们可以通过另一个 Tree-sitter 查询来实现它，这样我们就能完全控制大纲的展示方式。

下面是一个针对 Rust 的大纲查询示例代码片段：

```rust
(impl_item
  "impl" @context
  trait: (_)? @name
  "for"? @context
  type: (_) @name) @item
 
(function_item
  (visibility_modifier)? @context
  (function_modifiers)? @context
  "fn" @context
  name: (_) @name) @item
```

在此查询中，@name 捕获用于标记包含符号名的语法节点。@item 捕获则用于标记符号定义的整个节点，这一点对于识别不同符号之间的嵌套关系至关重要。@context 捕获则标记了那些其文本应被包含在大纲中的节点，这有助于展示符号定义的具体类型。

## 自动缩进功能
编辑器对语言的理解不仅在阅读代码时体现，编写代码时的自动缩进同样重要。大部分编程语言都有一套明确的缩进规则，这些规则通常基于特定的语法结构来决定何处应增加缩进。

Zed 通过一个额外的查询来实现这些缩进规则。在缩进查询中，每一次匹配都用来计算一个缩进区间——文件中的某个区间，在该区间内的每一行都应该比区间起始处的行多缩进一个层级。@indent 捕获用于标记定义了缩进区间的节点。@start 和 @end 捕获是可选的，可以用来调整缩进区间的大小。

比如，在这个为 JavaScript 设计的缩进查询示例中，语句块内部的内容会被缩进，直到遇到关闭的花括号所在的行。此外，几种多行表达式和语句会根据它们开始的行进行相对缩进：

```
(statement_block "}" @end) @indent
 
[
  (assignment_expression)
  (member_expression)
  (if_statement)
] @indent
```

这种简单的查询使得 Zed 能够正确地自动调整代码缩进，这是大多数代码编辑器在缩进调整上完全束手无策的地方：

```javascript
if (one)
    // this line is indented because it's part of the if statement
    two = three.four // this line is indented because it's part of a member expression
        .five(() => {
            six({
                seven: eight,
            })
        })
 
// this line is dedented to match the previous statement.
nine()
```

## 多语言文件
在处理许多编程语言时，单一的语法树无法完全捕捉源文件的全貌。例如，在HTML文件中，每个\<script\>标签包含的是独立的JavaScript代码段。在ERB这类模板语言中，文件实际上融合了HTML和Ruby两种语言，它们通过许多不连续的区域相互穿插组成。甚至在Rust语言中，每次宏调用传入的参数都需要被重新解析为一个小型的Rust文档，以便能够理解内部Rust表达式和声明的结构。

我们把这些内嵌的语法树称为语言注入（这个术语最初由TextMate编辑器提出）。就像前面提到的所有功能一样，Zed通过查询来定义每种语言针对语言注入的规则。比如，以下模式出自HTML注入查询，它指出\<script\>标签内部的内容应当被当作JavaScript来解析：

```
(script_element
  (raw_text) @content
  (#set! "language" "javascript"))
```

## 管理语法树集
在一些编程语言中，一个给定的缓冲区可能包含大量的注入语法树。以 Rust 为例，文件经常包含许多宏调用，我们为每个宏调用生成一个独立的 Rust 语法树。

读取语法树集合时，我们需要一种有效的方法来检索与文件的特定范围相交的树。为此，我们采用一种称为求和树的写时复制 B-树数据结构来存储语法树集合，这种结构在 Zed 中被广泛用于存储序列化集合（我们将在未来的博客文章中进一步探讨此结构）。

编辑缓冲区时，需要更新语法树集合以反映这些变更。所有与编辑操作相交的树都需重新解析。接着，在这些树中，我们要识别任何新增或移除的注入内容。为实现此目的，我们对受编辑影响的树范围执行注入查询。新注入的语法树可能包含更多注入内容，因此这是一个反复迭代的过程！

尽管这个流程较为复杂，但得益于 Tree-sitter 的增量解析和查询功能，以及求和树的高效搜索和分割操作，该过程非常迅速。即便在处理速度较慢的特殊情况下，编辑器也能保持响应性，这是因为求和树采用了一种高效的写时复制机制，允许我们在后台线程进行更新操作，同时在主线程上仍能使用数据的早期快照！

## 结束语
几年前，当我开始着手于 Tree-sitter 的开发时，我曾梦想有朝一日能够使用一款对代码语法有深度理解的轻量级编辑器。现在，随着我们在 Zed 中构建了坚实的语法感知基础，我终于拥有了一个完全符合我的工作方式的工具。我们还有很多空间去探索如何利用这些能力进一步提升代码编辑的体验。感谢您的阅读！
