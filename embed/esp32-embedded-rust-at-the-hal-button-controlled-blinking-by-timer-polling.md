# ESP32 Embedded Rust at the HALï¼šé€šè¿‡å®šæ—¶å™¨æ£€æµ‹å®ç°æŒ‰é’®æ§åˆ¶é—ªçƒåŠŸèƒ½

## ç›®å½•
* [ä»‹ç»](#ä»‹ç»)
    - ğŸ“š [å¿…å¤‡çŸ¥è¯†](#å¿…å¤‡çŸ¥è¯†)
    - ğŸ’¾ [è½¯ä»¶é…ç½®](#è½¯ä»¶é…ç½®)
    - ğŸ›  [ç¡¬ä»¶æ­å»º](#ç¡¬ä»¶æ­å»º)
        +  [ææ–™æ¸…å•](#ææ–™æ¸…å•)
* ğŸ‘¨â€ğŸ¨ [è½¯ä»¶è®¾è®¡](#è½¯ä»¶è®¾è®¡)
* ğŸ‘¨â€ğŸ’» [ä»£ç å®ç°](#ä»£ç å®ç°)
    - ğŸ“¥ [å¼•å…¥Crateåº“](#å¼•å…¥Crateåº“)
    - ğŸ› [å¤–å›´è®¾å¤‡é…ç½®ä»£ç ](#å¤–å›´è®¾å¤‡é…ç½®ä»£ç )
    - ğŸ“± [åº”ç”¨ä»£ç ](#åº”ç”¨ä»£ç )
* ğŸ“± [å®Œæ•´çš„ç¨‹åºä»£ç ](#å®Œæ•´çš„ç¨‹åºä»£ç )
* ğŸ”¬ [è¿›ä¸€æ­¥çš„å®éªŒä¸åˆ›æ„æ€è€ƒ](#è¿›ä¸€æ­¥çš„å®éªŒä¸åˆ›æ„æ€è€ƒ)
* [æ€»ç»“](#æ€»ç»“)

    æœ¬ç¯‡åšå®¢æ˜¯ä¸€ä¸ªç³»åˆ—æ–‡ç« ä¸­çš„ç¬¬äºŒç¯‡ï¼Œæˆ‘å°†åœ¨è¿™ä¸€ç³»åˆ—ä¸­åˆ©ç”¨HALå±‚çš„åµŒå…¥å¼Rustè¯­è¨€ï¼Œæ¢è®¨ESP32C3å¾®æ§åˆ¶å™¨çš„å„ç§å¤–å›´è®¾å¤‡ã€‚è¯·ç•™æ„ï¼Œåç»­æ–‡ç« ä¸­çš„æŸäº›æ¦‚å¿µå¯èƒ½ä¼šåŸºäºä¹‹å‰æ–‡ç« ä¸­ä»‹ç»çš„æ¦‚å¿µã€‚

å‰é¢çš„æ–‡ç« åŒ…æ‹¬ï¼ˆæŒ‰ç…§å‘å¸ƒé¡ºåºæ’åˆ—ï¼‰ï¼š
1. [ESP32 Embedded Rust at the HALï¼šåˆ©ç”¨GPIOæŒ‰é’®æ§åˆ¶LEDé—ªçƒ](esp32-embedded-rust-at-the-hal-gpio-button-controlled-blinking.md)

## ä»‹ç»

åœ¨æœ¬ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘å°†é€šè¿‡ä½¿ç”¨å®šæ—¶å™¨/è®¡æ•°å™¨å¤–å›´è®¾å¤‡æ¥ä¼˜åŒ–æˆ‘ä¹‹å‰æ–‡ç« ä¸­çš„GPIOæŒ‰é’®æ§åˆ¶LEDé—ªçƒé¡¹ç›®ã€‚åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­ï¼Œé‡ç‚¹è®¨è®ºçš„æ˜¯GPIOå¤–å›´è®¾å¤‡ï¼Œæˆ‘ç”¨è¿æ¥åˆ°GPIOè¾“å…¥çš„æŒ‰é’®æ¥æ§åˆ¶è¿æ¥åˆ°GPIOè¾“å‡ºçš„LEDçš„é—ªçƒé€Ÿåº¦ã€‚ä¹‹å‰çš„å»¶è¿Ÿæ˜¯é€šè¿‡ç¼–ç ç®—æ³•å®ç°çš„ï¼Œå³é€šè¿‡ä¸€æ®µå¾ªç¯ä»£ç æ¥ç”Ÿæˆå¿…è¦çš„å»¶è¿Ÿã€‚æ–‡ç« ä¸­ä¹Ÿæåˆ°ï¼Œä½¿ç”¨è½¯ä»¶æ–¹å¼æ¥äº§ç”Ÿå»¶è¿Ÿå¹¶ä¸ç†æƒ³ï¼Œå› ä¸ºè¿™ç§æ–¹å¼ä¸æ˜“æ‰©å±•ï¼Œè€Œç¡¬ä»¶æ–¹æ³•ï¼ˆä¾‹å¦‚ä½¿ç”¨å®šæ—¶å™¨å¤–è®¾ï¼‰åˆ™æ›´ä¸ºåˆé€‚ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å°†é€šè¿‡ä½¿ç”¨å®šæ—¶å™¨/è®¡æ•°å™¨å¤–è®¾æ¥æ§åˆ¶å»¶è¿Ÿï¼Œä»¥æ­¤æ¥å¢å¼ºåŸæœ‰ä»£ç ã€‚è¿™å°†ä½¿å¾—å»¶è¿Ÿæ›´åŠ ç¡®å®šä¸”åœ¨ä¸åŒå¹³å°é—´æ›´æ˜“äºæ‰©å±•ã€‚å†æ¬¡å¼ºè°ƒï¼Œæˆ‘å°†ä¸ä½¿ç”¨ä¸­æ–­ï¼Œè€Œæ˜¯é€šè¿‡è½®è¯¢å®šæ—¶å™¨/è®¡æ•°å™¨æ¥æ£€æµ‹ç»è¿‡çš„æ—¶é—´ã€‚

### ğŸ“š å¿…å¤‡çŸ¥è¯†

è¦ç†è§£æœ¬æ–‡çš„å†…å®¹ï¼Œä½ éœ€è¦å…·å¤‡ä»¥ä¸‹å‡ ç‚¹ï¼š

* Rustç¼–ç¨‹çš„åŸºç¡€çŸ¥è¯†ã€‚

* ç†Ÿæ‚‰ä½¿ç”¨Rustä¸ºESP32å¼€å‘åµŒå…¥å¼åº”ç”¨ç¨‹åºçš„åŸºæœ¬æ¨¡æ¿ï¼ˆ[ã€ŠRust on ESPã€‹](https://esp-rs.github.io/book/)ä¸€ä¹¦æ˜¯ä¸€ä»½å¾ˆå¥½çš„å‚è€ƒèµ„æ–™ï¼‰ã€‚

### ğŸ’¾ è½¯ä»¶é…ç½®

æœ¬æ–‡ä¸­æåˆ°çš„æ‰€æœ‰ä»£ç éƒ½å¯ä»¥åœ¨[apollolabs ESP32C3](https://github.com/apollolabsdev/ESP32C3) gitä»“åº“ä¸­æ‰¾åˆ°ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœä»“åº“ä¸­çš„ä»£ç æœ‰äº›è®¸ä¸åŒï¼Œè¿™å¯èƒ½æ˜¯ä¸ºäº†æå‡ä»£ç è´¨é‡æˆ–é€‚åº”HAL/Rustçš„æ›´æ–°è€Œåšçš„ä¿®æ”¹ã€‚

æ­¤å¤–ï¼Œå®Œæ•´çš„é¡¹ç›®ï¼ˆåŒ…æ‹¬ä»£ç å’Œæ¨¡æ‹Ÿï¼‰å¯ä»¥åœ¨[Wokwi](https://wokwi.com/projects/363050473642243073)çš„ç½‘ç«™ä¸Šæ‰¾åˆ°ã€‚

### ğŸ›  ç¡¬ä»¶æ­å»º
#### æ‰€éœ€ææ–™
* [ESP32-C3-DevKitM](https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/hw-reference/esp32c3/user-guide-devkitm-1.html)
![](https://cdn.hashnode.com/res/hashnode/image/upload/v1681796942083/da81fb7b-1f90-4593-a848-11c53a87821d.jpeg?auto=compress,format&format=webp)

* ä»»æ„é¢œè‰²çš„LEDç¯

* é™æµç”µé˜»

* æŒ‰é”®

#### ğŸ”Œ è¿æ¥æ–¹å¼
ğŸ“ æ³¨æ„

    *æ‰€æœ‰çš„è¿æ¥ç»†èŠ‚ä¹Ÿå±•ç¤ºåœ¨äº†[Wokwiç¤ºä¾‹](https://wokwi.com/projects/362145427195567105)ä¸­ã€‚*

è¿æ¥æ–¹å¼å¦‚ä¸‹ï¼š

* LEDçš„æ­£æé€šè¿‡ä¸€ä¸ªç”µé˜»è¿æ¥åˆ°å¼€å‘å¥—ä»¶çš„ç¬¬4å·å¼•è„šã€‚è¿™ä¸ªå¼•è„šå°†ç”¨ä½œè¾“å‡ºç«¯ã€‚LEDçš„è´Ÿæå°†è¿æ¥åˆ°åœ°çº¿ã€‚

* æŒ‰é’®çš„ä¸€ç«¯è¿æ¥åˆ°å¼€å‘å¥—ä»¶çš„ç¬¬0å·å¼•è„šã€‚è¿™ä¸ªå¼•è„šå°†ç”¨ä½œè¾“å…¥ç«¯ã€‚æŒ‰é’®çš„å¦ä¸€ç«¯ä¹Ÿå°†è¿æ¥åˆ°åœ°çº¿ã€‚


## ğŸ‘¨â€ğŸ¨ è½¯ä»¶è®¾è®¡
æœ¬æ–‡ä¸­çš„åº”ç”¨ç¨‹åºé‡‡å–äº†ä¸æˆ‘ä¹‹å‰[æ–‡ç« ](esp32-embedded-rust-at-the-hal-gpio-button-controlled-blinking.md)ä¸­ç›¸åŒçš„ç®—æ³•æµç¨‹ï¼Œä½†è¿›è¡Œäº†ä¸€äº›å°çš„ä¿®æ”¹ã€‚è¿™é‡Œï¼Œæˆ‘ä¸å†é€šè¿‡æ›´æ–°å¾ªç¯å˜é‡æ¥æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§å€¼ï¼Œè€Œæ˜¯é€šè¿‡è½®è¯¢ä¸€ä¸ªå®šæ—¶å™¨/è®¡æ•°å™¨æ¥åˆ¤æ–­æ˜¯å¦è¾¾åˆ°äº†é¢„å®šçš„å»¶è¿Ÿæ—¶é—´ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æŠŠè¿™äº›è°ƒæ•´èå…¥æµç¨‹å›¾ä¸­ï¼Œæ¥çœ‹çœ‹å®ƒçš„æœ€æ–°æ ·è²Œï¼š
![](https://cdn.hashnode.com/res/hashnode/image/upload/v1656580071411/5mWZAhHmk.png?auto=compress,format&format=webp)

ğŸš¨ é‡è¦è¯´æ˜ï¼š

    *å»¶è¿Ÿæ–¹æ³•æœ‰ä¸¤ç§ç±»å‹ï¼šé˜»å¡å’Œéé˜»å¡ã€‚é˜»å¡æ˜¯æŒ‡åœ¨å»¶è¿Ÿç»“æŸä¹‹å‰ï¼Œæ§åˆ¶å™¨å°†å¤„äºç©ºé—²çŠ¶æ€ï¼ˆæ“ä½œè¢«é˜»å¡ï¼‰ã€‚éé˜»å¡åˆ™æ„å‘³ç€å…è®¸æ¢å¤æ“ä½œï¼Œæ§åˆ¶å™¨å¯ä»¥åŒæ—¶æ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚ä»£ç ä¼šä¸æ–­è¿”å›å»æ£€æŸ¥ï¼ˆè½®è¯¢ï¼‰å®šæ—¶å™¨æ˜¯å¦ç»“æŸäº†å»¶è¿Ÿã€‚è¿™æ„å‘³ç€å¯¹äºæˆ‘ä»¬è¿™ç§éœ€è¦åœ¨æ—¶é—´æµé€çš„åŒæ—¶æ£€æŸ¥æŒ‰é’®æ˜¯å¦è¢«æŒ‰ä¸‹çš„è½®è¯¢æ–¹æ³•ï¼Œå¿…é¡»é‡‡ç”¨éé˜»å¡çš„æ–¹å¼ã€‚éœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸­æ–­ï¼Œè¿™ä¸€åˆ‡éƒ½ä¸ä¼šæ˜¯é—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬å°†æœ‰ä¸€ä¸ªä¸­æ–­æœåŠ¡ä¾‹ç¨‹æ¥å‘ŠçŸ¥æˆ‘ä»¬æŒ‰é’®è¢«æŒ‰ä¸‹ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œé™¤éç¦ç”¨äº†æŠ¢å åŠŸèƒ½ï¼Œå¦åˆ™ä¸­æ–­ä¸ä¼šå—åˆ°é˜»å¡å»¶è¿Ÿçš„å½±å“ã€‚*

ç°åœ¨ï¼Œè®©æˆ‘ä»¬å¼€å§‹å®ç°è¿™ä¸€ç®—æ³•ã€‚

## ğŸ‘¨â€ğŸ’» ä»£ç å®ç°

ğŸ“¥ å¼•å…¥Crateåº“ 

åœ¨è¿™ä¸ªå®ç°ä¸­ï¼Œéœ€è¦å¦‚ä¸‹ä¸‰ä¸ªcratesï¼š

esp_backtrace crateï¼Œç”¨äºå®šä¹‰ç¨‹åºå‘ç”ŸæƒŠææ—¶çš„è¡Œä¸ºã€‚

esp32c3_hal crateï¼Œç”¨äºå¼•å…¥ESP32C3è®¾å¤‡çš„ç¡¬ä»¶æŠ½è±¡å±‚ã€‚

```rust
use esp32c3_hal::{clock::ClockControl, pac::Peripherals, prelude::*, timer::TimerGroup, Rtc, Delay, IO};
use esp_backtrace as _;
```

ğŸ“ ç¬”è®°

    - æ¯ä¸ªcrateçš„å¯¼å…¥éƒ½éœ€è¦åœ¨Cargo.tomlæ–‡ä»¶ä¸­å¯¹åº”åœ°æ·»åŠ ä¾èµ–é¡¹ã€‚

    - åœ¨æ—©æœŸç‰ˆæœ¬çš„esp32c3_halä¸­ï¼Œéœ€è¦å¯¼å…¥riscv_rt crateä»¥æ”¯æŒ#[entry]å±æ€§å®çš„å¯åŠ¨ä»£ç ã€‚ä½†ä»0.7.0ç‰ˆæœ¬å¼€å§‹ï¼Œ#[entry]å±æ€§å·²è¢«æ•´åˆè¿›esp32c3_halä¸­ã€‚è¿™æ„å‘³ç€ä¸ºäº†æ”¯æŒ#[entry]å±æ€§ï¼Œä¸å†éœ€è¦å•ç‹¬å¯¼å…¥riscv_rt crateã€‚

### ğŸ› å¤–è®¾é…ç½®ä»£ç  
åœ¨æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä»£ç ä¹‹å‰ï¼Œéœ€è¦é€šè¿‡ä»¥ä¸‹æ­¥éª¤æ¥é…ç½®å¤–è®¾ï¼š

1ï¸âƒ£ è·å–è®¾å¤‡å¤–å›´è®¾å¤‡çš„å¥æŸ„ï¼šåœ¨åµŒå…¥å¼Rustç¼–ç¨‹ä¸­ï¼Œä½œä¸ºå•ä¾‹è®¾è®¡æ¨¡å¼çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦è·å–PACçº§åˆ«çš„å¤–è®¾ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨take()æ–¹æ³•æ¥å®Œæˆçš„ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªåä¸ºdpçš„è®¾å¤‡å¤–è®¾å¤„ç†ç¨‹åºï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
let peripherals = Peripherals::take();
```

ğŸ“ æ³¨æ„

    *è¿™æ˜¯ä¸esp32c3_halæ—©æœŸç‰ˆæœ¬ç›¸æ¯”çš„å¦ä¸€ä¸ªä¸åŒç‚¹ã€‚åœ¨ä»¥å‰çš„å®ç°ä¸­ï¼ŒPeripheralsæ˜¯ä»pacæ¨¡å—å¯¼å…¥çš„ï¼Œç°åœ¨åˆ™æ˜¯ä»peripheralsæ¨¡å—å¯¼å…¥çš„ã€‚è™½ç„¶ä¸¤è€…éƒ½ä½¿ç”¨takeæ–¹æ³•ï¼Œä½†è¯·æ³¨æ„ï¼Œåœ¨æ›´æ–°çš„å®ç°ä¸­ï¼Œå®ƒä¸ä¼šè¿”å›Resultç±»å‹ï¼Œå› æ­¤æ— éœ€è¿›è¡Œè§£åŒ…å¤„ç†ã€‚*

2ï¸âƒ£ ç¦ç”¨çœ‹é—¨ç‹—ï¼šä¸ä¹‹å‰çš„æ–‡ç« ä¸€æ ·ï¼ŒESP32C3é»˜è®¤å¯ç”¨äº†çœ‹é—¨ç‹—ï¼Œéœ€è¦å°†å…¶ç¦ç”¨ã€‚å¦‚æœä¸ç¦ç”¨ï¼Œè®¾å¤‡å°†ä¸æ–­é‡å¯ã€‚ä¸ºäº†é¿å…è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦åŠ å…¥ä»¥ä¸‹ä»£ç ï¼š

```rust
let system = peripherals.SYSTEM.split();
let clocks = ClockControl::boot_defaults(system.clock_control).freeze();

// Instantiate and Create Handles for the RTC and TIMG watchdog timers
let mut rtc = Rtc::new(peripherals.RTC_CNTL);
let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);
let mut wdt0 = timer_group0.wdt;
let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);
let mut wdt1 = timer_group1.wdt;
```

3ï¸âƒ£ å®ä¾‹åŒ–å¹¶åˆ›å»ºIOå¥æŸ„ï¼šæˆ‘ä»¬éœ€è¦å°†LEDå¼•è„šé…ç½®ä¸ºpush-pullè¾“å‡ºï¼Œå¹¶è·å¾—ä¸€ä¸ªå¥æŸ„æ¥æ§åˆ¶å®ƒã€‚æˆ‘ä»¬è¿˜éœ€è¦è·å¾—æŒ‰é’®è¾“å…¥å¼•è„šçš„å¥æŸ„ã€‚åœ¨æˆ‘ä»¬ä¸ºLEDå’ŒæŒ‰é’®è·å¾—ä»»ä½•å¥æŸ„ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªIOç»“æ„å®ä¾‹ã€‚IOç»“æ„å®ä¾‹æä¾›äº†ä¸€ä¸ªHALè®¾è®¡çš„ç»“æ„ä½“ï¼Œå…è®¸æˆ‘ä»¬è®¿é—®æ‰€æœ‰çš„GPIOå¼•è„šï¼Œä½¿æˆ‘ä»¬èƒ½ä¸ºå•ç‹¬çš„å¼•è„šåˆ›å»ºå¥æŸ„ã€‚è¿™ä¸å…¶ä»–HALä¸­ä½¿ç”¨çš„splitæ–¹æ³•æ¦‚å¿µç›¸ä¼¼ï¼ˆæ›´å¤šç»†èŠ‚å‚è§[æ­¤å¤„](https://apollolabsblog.hashnode.dev/demystifying-rust-embedded-hal-split-and-constrain-methodsï¼‰ã€‚æˆ‘ä»¬é€šè¿‡åœ¨IOç»“æ„ä¸Šè°ƒç”¨new()å®ä¾‹æ–¹æ³•æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
```

4ï¸âƒ£ è·å–LEDçš„å¥æŸ„å¹¶é…ç½®ä¸ºè¾“å‡ºï¼šå¦‚å‰æ‰€è¿°ï¼ŒLEDè¿æ¥åˆ°ç¬¬4å·å¼•è„šï¼ˆgpio4ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºLEDå¼•è„šåˆ›å»ºä¸€ä¸ªå¥æŸ„ï¼Œå¹¶ä½¿ç”¨into_push_pull_output()æ–¹æ³•å°†gpio4é…ç½®ä¸ºpush-pullè¾“å‡ºã€‚æˆ‘ä»¬å°†è¿™ä¸ªå¥æŸ„å‘½åä¸ºledï¼Œå¹¶æŒ‰ä»¥ä¸‹æ–¹å¼é…ç½®ï¼š

```rust
let mut led = io.pins.gpio4.into_push_pull_output();
```

[HALæ–‡æ¡£](https://docs.rs/esp32c3-hal/latest/esp32c3_hal/gpio/struct.GpioPin.html)é¡µé¢æä¾›äº†GpioPinç±»å‹æ”¯æŒçš„æ‰€æœ‰æ–¹æ³•çš„å®Œæ•´åˆ—è¡¨ã€‚

5ï¸âƒ£ è·å–å¹¶é…ç½®è¾“å…¥æŒ‰é’®çš„å¥æŸ„ï¼šå¦‚å‰æ‰€è¿°ï¼ŒæŒ‰é’®è¿æ¥åˆ°0å·å¼•è„šï¼ˆgpio0ï¼‰ã€‚æ­¤å¤–ï¼Œåœ¨æŒ‰é’®è¢«æŒ‰ä¸‹æ—¶ï¼Œå®ƒä¼šè¿æ¥åˆ°åœ°çº¿ã€‚å¯¹äºæŒ‰é’®æœªè¢«æŒ‰ä¸‹çš„çŠ¶æ€ï¼Œéœ€è¦åŠ å…¥ä¸€ä¸ªä¸Šæ‹‰ç”µé˜»ï¼Œä½¿å¼•è„šå˜é«˜ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨into_pull_up_input()æ–¹æ³•ä¸ºå¼•è„šé…ç½®ä¸€ä¸ªå†…éƒ¨ä¸Šæ‹‰ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
let button = io.pins.gpio0.into_pull_up_input();
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸LEDè¾“å‡ºä¸åŒï¼Œè¿™é‡Œçš„æŒ‰é’®å¥æŸ„ä¸éœ€è¦æ˜¯å¯å˜çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦è¯»å–å®ƒã€‚

6ï¸âƒ£ è·å–å¹¶é…ç½®å®šæ—¶å™¨ï¼šæˆ‘ä»¬é¦–å…ˆéœ€è¦è·å–å¯¹å®šæ—¶å™¨å¤–è®¾çš„è®¿é—®æƒé™ä»¥ä½¿ç”¨å…¶æ–¹æ³•ã€‚åœ¨ESP32ä¸­ï¼Œå®šæ—¶å™¨å­˜åœ¨äºæ‰€è°“çš„å®šæ—¶å™¨ç»„å†…ã€‚è¯·æ³¨æ„ï¼Œåœ¨ç¬¬2æ­¥ç¦ç”¨çœ‹é—¨ç‹—æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šå·²ç»ä¸ºtimer_group0åˆ›å»ºäº†ä¸€ä¸ªå¥æŸ„ï¼Œå³let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç°åœ¨éœ€è¦åšçš„å°±æ˜¯è·å–å¯¹timer0çš„è®¿é—®æƒï¼Œå¹¶æŒ‰ä»¥ä¸‹æ–¹å¼åˆ›å»ºä¸€ä¸ªå¥æŸ„ï¼š

```rust
let mut timer0 = timer_group0.timer0;
```

è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿè®¿é—®timer0çš„æ–¹æ³•ã€‚

è¿™å°±æ˜¯é…ç½®éƒ¨åˆ†çš„å…¨éƒ¨å†…å®¹ã€‚ç°åœ¨è®©æˆ‘ä»¬ç»§ç»­è¿›å…¥åº”ç”¨ç¨‹åºä»£ç çš„ç¼–å†™ã€‚

### ğŸ“± åº”ç”¨ç¨‹åºä»£ç 

æŒ‰ç…§ä¹‹å‰æè¿°çš„è®¾è®¡ï¼Œæˆ‘é¦–å…ˆéœ€è¦åˆå§‹åŒ–ä¸€ä¸ªå»¶è¿Ÿå˜é‡del_varï¼Œå¹¶è®¾ç½®LEDçš„è¾“å‡ºã€‚del_varéœ€è¦æ˜¯å¯å˜çš„ï¼Œå› ä¸ºå®ƒå°†åœ¨å»¶è¿Ÿå¾ªç¯ä¸­è¢«ä¿®æ”¹ã€‚æˆ‘è¿˜é€‰æ‹©é»˜è®¤å°†LEDçš„åˆå§‹è¾“å‡ºç”µå¹³è®¾ç½®ä¸ºä½ã€‚ä½¿ç”¨ä¹‹å‰æåˆ°çš„ç›¸åŒPinæ–¹æ³•ï¼Œæœ‰ä¸€ä¸ªset_low()æ–¹æ³•ï¼Œæˆ‘ä½¿ç”¨å®ƒæ¥å®ç°è¿™ä¸€ç›®æ ‡ã€‚

```rust
        // Initialize LED to on or off
    led.set_low().unwrap();

    // Create and initialize a delay variable to manage delay duration
    let mut del_var = 2000_u32.millis();
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºdel_varï¼Œæˆ‘ä½¿ç”¨çš„æ˜¯Durationç±»å‹ã€‚millis()æ˜¯ä¸€ä¸ªå°†æ•°å­—è½¬æ¢ä¸ºDurationçš„æ–¹æ³•ã€‚

æ¥ä¸‹æ¥ï¼Œåœ¨ç¨‹åºå¾ªç¯ä¸­ï¼Œæˆ‘é¦–å…ˆå¯åŠ¨è®¡æ•°å™¨ã€‚æŸ¥é˜…[å®šæ—¶å™¨æ–‡æ¡£](https://docs.rs/esp32c3-hal/0.8.0/esp32c3_hal/timer/struct.Timer.html)ä¸­å¯ç”¨çš„æ–¹æ³•ï¼Œæœ‰ä¸€ä¸ªstartæ–¹æ³•ï¼Œå…¶ç­¾åå¦‚ä¸‹ï¼š

```rust
fn start<Time>(&mut self, timeout: Time)
where
    Time: Into<<Timer<T> as CountDown>::Time>,
```

è¿™ä¸ªæ–¹æ³•å¯åŠ¨å®šæ—¶å™¨ï¼Œå¼€å§‹è®¡ç®—ä¸€ä¸ªæŒ‡å®šçš„è¶…æ—¶æŒç»­æ—¶é—´ã€‚timeoutå‚æ•°æ˜¯ä¸€ä¸ªæ³›å‹Timeã€‚åœ¨åº”ç”¨ç¨‹åºå¾ªç¯ä¸­ï¼Œå®šæ—¶å™¨æ¥ç€æŒ‰ä»¥ä¸‹æ–¹å¼å¯åŠ¨ï¼š

```rust
timer0.start(del_var);
```

åœ¨å¯åŠ¨å®šæ—¶å™¨ä¹‹åï¼Œæˆ‘ç°åœ¨éœ€è¦æŒç»­è½®è¯¢å®šæ—¶å™¨ä»¥è·å–å·²è¿‡å»çš„æ—¶é—´ã€‚ä½œä¸ºå®šæ—¶å™¨å¯ç”¨[æ–¹æ³•](https://docs.rs/stm32f4xx-hal/latest/stm32f4xx_hal/timer/counter/struct.Counter.html)çš„ä¸€éƒ¨åˆ†ï¼Œæœ‰ä¸€ä¸ªwaitæ–¹æ³•ï¼Œå…¶ç­¾åå¦‚ä¸‹ï¼š

```
fn wait(&mut self) -> Result<(), Error<Void>>
```

è¿™ä¸ªæ–¹æ³•éé˜»å¡åœ°â€œç­‰å¾…â€å€’è®¡æ—¶ç»“æŸï¼Œå¹¶è¿”å›ä¸€ä¸ªResultç±»å‹ã€‚å¦‚æœResultæ˜¯Ok()ï¼Œåˆ™è¡¨ç¤ºå€’è®¡æ—¶å·²å®Œæˆï¼ˆå®šæ—¶å™¨åˆ°æœŸï¼‰ã€‚è¿™æ ·å°±å½¢æˆäº†ä»¥ä¸‹åº”ç”¨ç¨‹åºå¾ªç¯ï¼š

```rust
// Application Loop
loop {
    // Start counter with with del_var duration
    timer0.start(del_var);
    // Enter loop and check for button press until counter reaches del_var
    while timer0.wait() != Ok(()) {
        if button.is_low().unwrap() {
            // If button pressed decrease the delay value by 500 ms
            del_var = del_var - 500_u32.millis();
            // If updated delay value drops below 500 ms then reset it back to starting value to 2 secs
            if del_var.to_millis() < 1000_u32 {
               del_var = 2000_u32.millis();
            }
            // Exit delay loop since button was pressed
            break;
        }
    }
    // Toggle LED
    led.toggle().unwrap();
}
```

åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°æˆ‘åˆ›å»ºäº†ä¸€ä¸ªwhileå¾ªç¯ï¼Œä¸æ–­è½®è¯¢timer0ï¼Œç›´åˆ°å®ƒè¾¾åˆ°ç­‰åŒäº2ç§’çš„del_varã€‚å¦‚è®¾è®¡éƒ¨åˆ†æ‰€è¿°ï¼Œå¦‚æœå¾ªç¯è‡ªç„¶ç»“æŸï¼Œåˆ™del_varä¿æŒä¸å˜ã€‚åœ¨å»¶è¿ŸæœŸé—´çš„ä»»ä½•æ—¶åˆ»ï¼Œå¦‚æœæŒ‰é’®è¢«æŒ‰ä¸‹ï¼Œæˆ‘å¯ä»¥ä½¿ç”¨is_low()æ–¹æ³•æ¥æ£€æµ‹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘å°†del_varå‡å°‘500.millis()çš„æŒç»­æ—¶é—´ã€‚å¦‚æœæœ€ç»ˆå¾—åˆ°çš„del_varå€¼å°äº500_u32ï¼Œåˆ™æˆ‘å°†æ¢å¤åˆå§‹è®¾å®šçš„2001.millis()çš„å€¼ã€‚

ğŸš¨ é‡è¦è¯´æ˜ï¼š

    *ä¸ä¸Šä¸€ç¯‡æ–‡ç« ä¸€æ ·ï¼Œä¸€æ—¦è¿è¡Œä»£ç ï¼Œä½ ä¼šçœ‹åˆ°LEDåœ¨é—ªçƒï¼Œä½†å¯èƒ½ä¼šæ³¨æ„åˆ°ä¸€äº›å¼‚å¸¸è¡Œä¸ºã€‚é—ªçƒé¢‘ç‡ä¼¼ä¹ä¼šä»¥éšæœºé¡ºåºå˜åŒ–ã€‚è¿™æ˜¯å› ä¸ºæœºæ¢°æŒ‰é’®ä¸Šçš„â€œæŠ–åŠ¨â€æ•ˆåº”ã€‚åœ¨Wokwiä¸­ï¼Œä¹Ÿå¯ä»¥æ¶ˆé™¤æŠ–åŠ¨æ•ˆåº”ã€‚æœ‰å…³æ›´å¤šç»†èŠ‚ï¼Œè¯·æŸ¥çœ‹ä¸‹é¢çš„å®éªŒæ€è·¯éƒ¨åˆ†ã€‚*


## ğŸ“± å®Œæ•´çš„åº”ç”¨ç¨‹åºä»£ç 

è¿™æ˜¯æœ¬æ–‡æè¿°å®ç°çš„å®Œæ•´ä»£ç ã€‚ä½ è¿˜å¯ä»¥åœ¨[apollolabs ESP32C3](https://github.com/apollolabsdev/ESP32C3) gitä»“åº“ä¸Šæ‰¾åˆ°è¿™ä¸ªå®Œæ•´é¡¹ç›®å’Œå…¶ä»–é¡¹ç›®ã€‚æ­¤å¤–ï¼ŒWokwié¡¹ç›®å¯ä»¥åœ¨[è¿™é‡Œ](https://wokwi.com/projects/362145427195567105)è®¿é—®ã€‚

```rust
#![no_std]
#![no_main]

use esp32c3_hal::{
    clock::ClockControl, peripherals::Peripherals, prelude::*, timer::TimerGroup, Rtc, IO,
};
use esp_backtrace as _;

#[entry]
fn main() -> ! {
    // Take Peripherals, Initialize Clocks, and Create a Handle for Each
    let peripherals = Peripherals::take();
    let system = peripherals.SYSTEM.split();
    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();

    // Instantiate and Create Handles for the RTC and TIMG watchdog timers
    let mut rtc = Rtc::new(peripherals.RTC_CNTL);
    let timer_group0 = TimerGroup::new(peripherals.TIMG0, &clocks);
    let mut wdt0 = timer_group0.wdt;
    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &clocks);
    let mut wdt1 = timer_group1.wdt;

    // Disable the RTC and TIMG watchdog timers
    rtc.swd.disable();
    rtc.rwdt.disable();
    wdt0.disable();
    wdt1.disable();

    // Instantiate and Create Handle for IO
    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);

    // Instantiate and Create Handle for LED output & Button Input
    let mut led = io.pins.gpio4.into_push_pull_output();
    let button = io.pins.gpio0.into_pull_up_input();

    // Instantiate and Create Handle for Timer
    let mut timer0 = timer_group0.timer0;

    // Initialize LED to on or off
    led.set_low().unwrap();

    // Create and initialize a delay variable to manage delay duration
    let mut del_var = 2000_u32.millis();

    // Application Loop
    loop {
        // Start counter with with del_var duration
        timer0.start(del_var);
        // Enter loop and check for button press until counter reaches del_var
        while timer0.wait() != Ok(()) {
            if button.is_low().unwrap() {
                // If button pressed decrease the delay value by 500 ms
                del_var = del_var - 500_u32.millis();
                // If updated delay value drops below 500 ms then reset it back to starting value to 2 secs
                if del_var.to_millis() < 1000_u32 {
                    del_var = 2000_u32.millis();
                }
                // Exit delay loop since button was pressed
                break;
            }
        }
        // Toggle LED
        led.toggle().unwrap();
    }
}
```

## ç»“è®º
åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬åˆ©ç”¨ESP32C3çš„GPIOå’Œè®¡æ•°å™¨å¤–è®¾åˆ›å»ºäº†ä¸€ä¸ªLEDæ§åˆ¶åº”ç”¨ç¨‹åºã€‚æ‰€æœ‰ä»£ç éƒ½æ˜¯åŸºäºè½®è¯¢ï¼ˆä¸ä½¿ç”¨ä¸­æ–­ï¼‰å®ç°çš„ï¼Œè¿™æ„å‘³ç€åŒæ ·åˆ©ç”¨äº†éé˜»å¡è®¡æ•°å™¨ã€‚æ‰€æœ‰ä»£ç éƒ½æ˜¯åœ¨HALå±‚çº§ï¼Œå¹¶ä½¿ç”¨[esp32c3-hal](https://docs.rs/esp32c3-hal/latest/esp32c3_hal/)åˆ›å»ºçš„ã€‚
